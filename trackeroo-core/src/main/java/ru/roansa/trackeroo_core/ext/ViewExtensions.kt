package ru.roansa.trackeroo_core.ext

import android.content.res.Resources
import android.view.View
import android.view.ViewGroup
import android.widget.AbsListView
import android.widget.ScrollView
import androidx.core.view.ScrollingView
import androidx.core.view.children
import androidx.core.view.isVisible
import ru.roansa.trackeroo_core.hookers.ViewHooker
import ru.roansa.trackeroo_core.hookers.view.ViewComponent
import ru.roansa.trackeroo_core.hookers.view.ViewType
import java.util.LinkedList
import java.util.Queue

//TODO is there a way to optimize it with recursion?
internal fun View.findTarget(
    touchX: Float,
    touchY: Float,
    targetViewType: ViewType
): ViewComponent? {
    val viewsQueue: Queue<View> = LinkedList()
    var targetComponent: ViewComponent? = null
    viewsQueue.add(this)

    while (viewsQueue.isNotEmpty()) {
        val currentQueueView = viewsQueue.poll() ?: return null

        if (currentQueueView is ViewGroup) {
            viewsQueue.addAll(currentQueueView.children)
        }

        ViewHooker.gestureTargetLocators.forEach { gestureLocator ->
            val newTargetComponent =
                gestureLocator.findTarget(currentQueueView, touchX, touchY, targetViewType) ?: return@forEach

            if (targetViewType == ViewType.CLICKABLE) targetComponent = newTargetComponent
            else return newTargetComponent
        }
    }

    return targetComponent
}

fun View.isScrollable(isAndroidXAvailable: Boolean): Boolean {
    val isAndroidxScrollable =
        if (!isAndroidXAvailable) false
        else ScrollingView::class.java.isAssignableFrom(this.javaClass)

    return isAndroidxScrollable || AbsListView::class.java.isAssignableFrom(this.javaClass)
            || ScrollView::class.java.isAssignableFrom(this.javaClass) && this.isVisible
}

fun View.isTouchable(): Boolean = this.isClickable && this.isVisible

/**
 * Method returns human-readable name of view (according to its resource id in xml file)
 * @throws Resources.NotFoundException
 */
fun View.resourceId(): String? {
    val viewId = this.id
    if (viewId == View.NO_ID || isViewIdGenerated(viewId)) return null

    this.context.resources?.let { return it.getResourceEntryName(viewId) } ?: return ""
}

/**
 * Method returns human-readable name of view (according to its resource id in xml file) but with fallback
 * If id was autogenerated, the method returns hex representation of this id
 * @return human-readable view id
 */
internal fun View.getResourceIdOrHex(): String? {
    val viewId = this.id
    return try {
        resourceId()
    } catch (ex: Resources.NotFoundException) {
        "0x${Integer.toHexString(viewId)}"
    }
}

/**
 * Method checks if view id was generated by View.generateViewId
 * This is a copy of private method of View class
 *
 * According to source code of View.generateViewId, this method can generate id in range of 0 to 00FFFFFF values
 * Range of 00FFFFFF to FFFFFFFF is reserved for xml resource ids
 *
 * In that case need to check if view has autogenerated id and hadn't human-readable name for this id
 */
private fun isViewIdGenerated(id: Int): Boolean =
    (id and 0xFF00000) == 0 && (id and 0x00FFFFFF) != 0